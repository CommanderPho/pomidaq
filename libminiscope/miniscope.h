/*
 * Copyright (C) 2019-2020 Matthias Klumpp <matthias@tenstral.net>
 *
 * Licensed under the GNU Lesser General Public License Version 3
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the license, or
 * (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this software.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef MINISCOPE_H
#define MINISCOPE_H

#include <memory>
#include <functional>
#include <opencv2/core.hpp>

#include "mediatypes.h"

#ifdef _WIN32
#define MS_LIB_EXPORT __declspec(dllexport)
#else
#define MS_LIB_EXPORT __attribute__((visibility("default")))
#endif

namespace MScope
{

using milliseconds_t = std::chrono::milliseconds;

enum class BackgroundDiffMethod {
    None,
    Subtraction,
    Division
};

class MiniScopeData;
class MS_LIB_EXPORT MiniScope
{
public:
    explicit MiniScope();
    ~MiniScope();

    void setScopeCamId(int id);
    int scopeCamId() const;

    void setExposure(double value);
    double exposure() const;

    void setGain(double value);
    double gain() const;

    void setExcitation(double value);
    double excitation() const;

    bool connect();
    void disconnect();

    bool run();
    void stop();
    bool startRecording(const std::string& fname = "");
    void stopRecording();

    bool running() const;
    bool recording() const;
    bool captureStartTimeInitialized() const;

    void setOnMessage(std::function<void(const std::string&, void*)> callback, void *udata = nullptr);
    void setPrintMessagesToStdout(bool enabled);

    bool useColor() const;
    void setUseColor(bool color);

    void setVisibleChannels(bool red, bool green, bool blue);
    bool showRedChannel() const;
    bool showGreenChannel() const;
    bool showBlueChannel() const;

    /**
     * @brief Called *in the DAQ thread* when a frame was acquired.
     *
     * This callback is executed for each raw frame acquired from the Miniscope, and is equivalent
     * to what would be recorded to a video file.
     * The first timestamp is the timestamp of the frame in milliseconds. The callee may modify it,
     * to change the timestamp of a frame while it is being processed.
     *
     * The second timestamp parameter is the timestamp of the computer's clock when the frame
     * was - highly likely - acquired ("master timestamp").
     * The third timestamp parameter is the adjusted timestamp generated by the driver or device.
     * Both timestamps may already have been preprocessed a bit (adjusted for the selected start-time
     * and timestamp type), so you may not get completely "raw" timestamps.
     *
     * Please note that this function will also be called in case we are dropping frames. In this case, the
     * frame data matrix will be empty.
     */
    void setOnFrame(std::function<void(const cv::Mat &, milliseconds_t &, const milliseconds_t &, const milliseconds_t &, void *)> callback, void *udata = nullptr);

    /**
     * @brief Called *in the DAQ thread* when a frame was acquired on the edited frame.
     *
     * This callback is executed for each (possibly modified) "display frame" that an application like
     * PoMiDAQ would show to the user.
     */
    void setOnDisplayFrame(std::function<void(const cv::Mat &, const milliseconds_t &, void *)> callback, void *udata = nullptr);

    cv::Mat currentDisplayFrame();
    uint currentFps() const;
    size_t droppedFramesCount() const;

    uint fps() const;
    void setFps(uint fps);

    void setCaptureStartTime(const std::chrono::time_point<std::chrono::steady_clock> &startTime);
    bool useUnixTimestamps() const;
    void setUseUnixTimestamps(bool useUnixTime);
    milliseconds_t unixCaptureStartTime() const;

    bool externalRecordTrigger() const;
    void setExternalRecordTrigger(bool enabled);

    std::string videoFilename() const;
    void setVideoFilename(const std::string& fname);

    VideoCodec videoCodec() const;
    void setVideoCodec(VideoCodec codec);

    VideoContainer videoContainer() const;
    void setVideoContainer(VideoContainer container);

    bool recordLossless() const;
    void setRecordLossless(bool lossless);

    int minFluorDisplay() const;
    void setMinFluorDisplay(int value);

    int maxFluorDisplay() const;
    void setMaxFluorDisplay(int value);

    int minFluor() const;
    int maxFluor() const;

    BackgroundDiffMethod displayBgDiffMethod() const;
    void setDisplayBgDiffMethod(BackgroundDiffMethod method);

    double bgAccumulateAlpha() const;
    void setBgAccumulateAlpha(double value);

    uint recordingSliceInterval() const;
    void setRecordingSliceInterval(uint minutes);

    std::string lastError() const;

    milliseconds_t lastRecordedFrameTime() const;

private:
    MiniScopeData *d;

    void setLed(double value);
    void addDisplayFrameToBuffer(const cv::Mat& frame, const milliseconds_t &timestamp);
    static void captureThread(void *msPtr);
    void startCaptureThread();
    void finishCaptureThread();
    void emitMessage(const std::string& msg);
    void fail(const std::string& msg);
};

} // end of MiniScope namespace

#endif // MINISCOPE_H
